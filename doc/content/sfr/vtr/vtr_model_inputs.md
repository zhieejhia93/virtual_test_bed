# Model Inputs

There are two VTR models stored on the virtual test bed; a standalone
neutronics model and multi-physics model.
There are additional sub-app input files that are used by the multi-physics model
that can be ran standalone with slight modification.
In the preceding sections, we will walk through the input files for the
Griffin standalone model and multi-physics model.

## Griffin Standalone

The complete input file for the Griffin neutronics model is shown below.

!listing sfr/vtr/steady/griffin_only.i 


### Model Parameters

The first block is for model parameters.
This could include the reactor state point (fuel temperature, 
coolant temperature/density, etc.), reactor power level, or any
user-desired information.
For consistency, the initial state point is set with the state on 
the cross section file.
The cross sections for this model are not parameterized, instead, there only 
exists one state point. 
We'll see that the standalone model is used to verify the neutronics solution
and multi-group cross section library to Serpent.
The power for the VTR is 300 MW and set with `tpow`.

### Global Parameters

Global paremeters are parameters that may be referenced
throughout the input file.
This block is user specific; the purpose is
to simplify repeated variable entries.
However, be careful to not override a default parameter
option in a later block without meaning to.

For this model, we store cross section information here.
Notice that the library name and file location are defined.
For simplicity, all of the cross section files are stored in the
`xs` directory.
Also, the cross section parameterization (names and variables) 
on the xml file are set.
Even though the library is not parameterized, we still note the state variables
at which the cross sections are generated at.
The unit of the cross sections are specified with the logical, `is_meter`,
either meters or centimeters.
We also define the materials as a "pseudo" mixture with
a density of 1.0, which refers to the homogenized cross
sections generated with Serpent and processed with ISOXML.

If these definitions do not make sense now, we will
walk-through their uses and meanings in the subsequent
blocks.

!listing sfr/vtr/steady/griffin_only.i 
         block=GlobalParams

### Geometry and Mesh

In this section, we will cover the mesh inputs.
The full mesh block can be found below.

!listing sfr/vtr/steady/griffin_only.i 
         block=Mesh

The computational mesh is generated with CUBIT, an external code developed at 
Sandia Nationa Labs, from the VTR geometry.
An internal INL tool is used to post-process the mesh to ensure
consistency with the Serpent generated multi-group cross section
library (i.e. material region and equivalent region identification).
The resulting output is an Exodus file that is read by MOOSE 
using the [!style color=orange](FileMeshGenerator) type. 
We need to directly specify the ids on the mesh using 
[!style color=red](exodus_extra_element_integers) 
which will then read in the material ids and equivalent ids 
(for the SPH factors). 
This is performed with the [!style color=orange](ExtraElementIDCopyGenerator) 
type by defining the "equivalence_id" as the source 
(from [!style color=red](exodus_extra_element_integers))
and "equivalence_id" as the target.
A simple way to identifiy the material and equivalent ids is to
open the mesh file `vtr_core.e` 
in an Exodus supported visualization tool (i.e. ParaView).
All of the mesh files are stored in the `mesh` directory.

### Equivalence

Equivalent cross sections are handled in the `[Equivalent]` block. 
Super homogenization (SPH) factors are generated in Serpent to 
correct homogenization errors and preserve the reaction rates 
of the heterogenous solution. 
For convenience, all of the equivalence files are stored in the
`sph` directory.
The equivalence library is first defined with 
[!style color=red](equivalance_library) which is an xml file
generated by the ISOXML pre-processing code.
The [!style color=red](equivalence_grid_names) and 
[!style color=red](equivalence_grid_variables) are then specified 
with the state point variables on the equivalence library. 
These variables define the SPH factor parameterization.
In this model, the cross section library consists of only one 
state point, made up of fuel temperature, coolant temperature,
and control rod fraction state parameters.
The `compute_factors = false` simply tells the system to use the SPH factors 
directly from the equivalence library.
The "CFEM-Diffusion" is defined in the `[Transport Systems]` block.

!listing sfr/vtr/steady/griffin_only.i 
         block=Equivalence

### AuxVariables and AuxKernels

There are three AuxVariables that are defined in this model;
the fuel temperature, coolant temperature, and control rod
fraction.
These variables are defined to represent the state parameters
that parameterize the cross section and equivalence libraries.
The values for these variables are set with a parsed expression from
the model parameters derfined at the top of the input file.

!listing sfr/vtr/steady/griffin_only.i 
         block=AuxVariables

There are no AuxKernels that act on these variables since there are
no derived quantities to obtain.

### Initial Conditions and Functions

User specified functions are defined in this block.
Here, we constuct a function for the control rod movement.
The type is set with the 
[!style color=orange](ConstantFunction) parameter and the value
equal to the all rods out case (1.92). 
This value can be changed to obtain ARO, ARI, and fractional rod cases.

!listing sfr/vtr/steady/griffin_only.i 
         block=Functions

### Materials

Material cross sections are specified with the multi-group 
cross section library defined by [!style color=red](library_file) 
in the `[GlobalParameters]` block. 
In this model, we define three types of materials: fuel materials, 
materials for the reflector/shield/SR assemblies, and control rod materials. 
The first two materials are given the
[!style color=orange](CoupledFeedbackMatIDNeutronicsMaterial) type. 
This type uses neutronics properties based on mixed isotopes 
from the multi-group cross section library. 
It also allows the assignment of cross sections based on dynamic state
variables (i.e. the AuxVariables defined above).
In this example, we have a pseudo mixture and density that is 
defined in the `[GlobalParameters]` block.
We must specify which blocks are fissile materials with the 
[!style color=red](block) card. 
The block ids can be identified on the mesh with an Exodus 
supported viewer (i.e. ParaView).
For each block id, we also need to identify the densities and isotopes. 
For convenience, these parameters were put in the `[GlobalParameters]` block.
The [!style color=red](plus) card indicates if absorption, fission, and
kappa fission are to be used (for fissile materials).

The control rod materials are given the 
[!style color=orange](CoupledFeedbackRoddedNeutronicsMaterial) type. 
First, the [!style color=red](segment_material_ids) sets the materials
of the control rod.
The absorption region of the control rod is identified with the `116` id.
The length of the rod segments are set with 
[!style color=red](segment_material_ids).
Only the active control rod segment lengths are declared.
Next, a control rod function is specified for withdrawal as well as
the withdrawal direction with [!style color=red](front_position_function)
and [!style color=red](rod_withdrawn_direction), respectively.
The control rod function is defined in the `[Functions]` block.
Lastly, the pseudo isotope mixture and density is declared for the control
rod segments.

!listing sfr/vtr/steady/griffin_only.i 
         block=Materials

The power density is not calculated implicitly and must be defined in 
the `[PowerDensity]` block. 
This block provides the power density with a user specified power and 
the proper flux scaling factor in the postprocessor. 
The two required arguments are [!style color=red](power) and 
[!style color=red](power_density_variable). 
The power is in units of Watts.
The [!style color=red](power_density_variable) simply sets 
the variable name. 
Optional arguments include the post-processors to use. 
The [!style color=red](integrated_power_postprocessor) sets the 
desired name for the integrated power post-processor. 
Likewise, the [!style color=red](power_scaling_postprocessor) 
sets the desired name for the power scaling post-processor. 
Lastly, the family and order parameters are the polynomial 
representations  of the power density corresponding to the 
underlying FEM.

!listing sfr/vtr/steady/griffin_only.i 
         block=PowerDensity

### Transport System

The transport system is the heart of the Griffin simulation.
We define the transport particle and eigenvalue equation with
[!style color=red](particle) and
[!style color=red](equation_type), respectively.
The number of energy groups is set to "6" with 
[!style color=red](G).
Vacuum boundary conditions are imposed on side sets "1 2 3".
The `[./CFEM-Diffusion]` sub-block defines the method to solve the
problem.
We use Griffin's diffusion method built on the MOOSE 
continuous finite element method solver.
Finite element parameters are set with the 
[!style color=red](family) and 
[!style color=red](order), which define the family of
functions used to approximate the solution and 
polynomial order.
The last two options, 
[!style color=red](assemble_scattering_jacobian) and
[!style color=red](assemble_fission_jacobian) are
required to use the "PJFNKMO" method defined later in the
`[Executioner]`.
This tells the finite element solver to not update the material
cross sections at each linear iteration.

!listing sfr/vtr/steady/griffin_only.i 
         block=TransportSystems

### Executioner

The `[Executioner]` block tells the solver what type of problem 
it needs to solve.
Here, we select [!style color=orange](Eigenvalue) as the executioner 
type which will solve the eigenvalue problem for the criticality 
and multi-group scalar flux (eigenvalue and eigenvectors). 
We also specify to solve with a Preconditioned Jacobian Free 
Newton Krylov Matrix Only method by setting 
[!style color=red](solve_type) equal to "PJFNKMO". 
The Matrix Only method forces the solver to not update
material properties (i.e. cross sections) in the linear iterations
of the solve.
To use this solver, the [!style color=red](constant_matrices) 
parameter must be set to "true".
There are a number of optional arguments that may also be included.
For example, we define a few petsc options and non-linear solver
tolerances.

The quadrature sub-block adds a custom quadrature rule.
In this case, it is set to a fourth order.

!listing sfr/vtr/steady/griffin_only.i 
         block=Executioner

### Multi-apps and Transfers

This model is to run Griffin neutronics only.
In the multi-physics model, we will declare sub-apps that include
BISON and SAM.

### Post-processors, Debug, and Outputs

The last blocks are for post-processors, debug options, and outputs. 
A post-processor can be thought of as a function to derive a variable
of interest from the solution.
For example, the power density.
This is defined with the 
[!style color=orange](ElementIntegralVariablePostprocessor) 
type and the power density variable we created earlier,
[!style color=red](power_density). 
The [!style color=red](power_density) variable declares at what point
in the calculation to obtain the power density.
For example, we've declared at the start of the calculation and at
the end of each timestep. 

!listing sfr/vtr/steady/griffin_only.i 
         block=Postprocessors

The debug options can be helpful when debugging a case. 
These are a set of true (1) and false (0) options to print statements. 

!listing sfr/vtr/steady/griffin_only.i 
         block=Debug

Finally, the output block sets the output files from the simulation. 
Two of the most common options include the exodus and csv file. 
The Exodus file can be viewed with the same software as the mesh, 
but now will show the solution and solution derived quantities such 
as the multi-group scalar flux and power distribution. 
The csv file stores a summary of the solution that includes 
the criticality.
The [!style color=red](perf_graph) parameter is helpful to evaluate
the computational run time.

!listing sfr/vtr/steady/griffin_only.i 
         block=Outputs

# How to run the model

The model can be ran with Griffin in serial or parallel.
In serial, the solve takes approximately 1 min 40 sec on a 
Xeon Platinum 8268 processor.
In parallel, with 48 processors, the solve takes approximately 6 seconds.


Run it via:

 `griffin-opt -i griffin_only.i`

 `mpirun -n 48 griffin-opt -i griffin_only.i`

The performance graph in serial is displayed below. 


|                                Section                               | Calls |   Self(s)  |   Avg(s)   |    %   | Mem(MB) |  Total(s)  |   Avg(s)   |    %   | Mem(MB) |
|                                   -                                  |     - |         -  |         -  |      - |       - |         -  |         -  |     -  |      -  |
| GriffinApp (main)                                                    |     1 |      0.024 |      0.024 |   0.02 |       4 |    119.203 |    119.203 | 100.00 |    1205 |
|   Action::SetupMeshAction::Mesh::SetupMeshAction::act::setup_mesh    |     1 |      0.001 |      0.001 |   0.00 |       0 |      0.001 |      0.001 |   0.00 |       0 |
|   Action::SetupMeshAction::Mesh::SetupMeshAction::act::set_mesh_base |     2 |      0.000 |      0.000 |   0.00 |       0 |      0.000 |      0.000 |   0.00 |       0 |
|   MooseApp::executeMeshGenerators                                    |     1 |      0.000 |      0.000 |   0.00 |       0 |      0.000 |      0.000 |   0.00 |       0 |
|   Eigenvalue::final                                                  |     1 |      0.000 |      0.000 |   0.00 |       0 |      0.001 |      0.001 |   0.00 |       0 |
|     EigenProblem::outputStep                                         |     1 |      0.001 |      0.001 |   0.00 |       0 |      0.001 |      0.001 |   0.00 |       0 |
|   EigenProblem::computeUserObjects                                   |     2 |      9.956 |      4.978 |   8.35 |       0 |      9.956 |      4.978 |   8.35 |       0 |
|   EigenProblem::computeUserObjects                                   |     2 |     10.021 |      5.010 |   8.41 |       0 |     10.021 |      5.010 |   8.41 |       0 |
|   EigenProblem::outputStep                                           |     2 |      0.002 |      0.001 |   0.00 |       0 |      0.843 |      0.422 |   0.71 |       3 |
|     Exodus::outputStep                                               |     2 |      0.839 |      0.419 |   0.70 |       3 |      0.839 |      0.419 |   0.70 |       3 |
|   Eigenvalue::PicardSolve                                            |     1 |      0.001 |      0.001 |   0.00 |       0 |     64.431 |     64.431 |  54.05 |     515 |
|     EigenProblem::computeUserObjects                                 |     1 |      5.015 |      5.015 |   4.21 |       0 |      5.015 |      5.015 |   4.21 |       0 |
|     EigenProblem::outputStep                                         |     1 |      0.001 |      0.001 |   0.00 |       0 |      0.001 |      0.001 |   0.00 |       0 |
|     EigenProblem::solve                                              |     1 |     15.113 |     15.113 |  12.68 |     326 |     59.415 |     59.415 |  49.84 |     515 |
|       EigenProblem::computeUserObjects                               |     2 |      9.934 |      4.967 |   8.33 |       0 |      9.934 |      4.967 |   8.33 |       0 |
